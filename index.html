<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WHYTEGOD Protocol — Phase 11</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body{font-family:Arial,sans-serif;background:#0b0f19;color:#fff;margin:0}
.container{max-width:1100px;margin:auto;padding:20px}
h1,h2,h3{color:#4da3ff}
.box{background:#121829;padding:20px;margin-bottom:20px;border-radius:8px}
textarea,input{width:100%;padding:10px;border-radius:5px;border:none;margin-top:10px}
button{background:#4da3ff;color:#000;padding:12px 20px;border:none;border-radius:5px;font-size:16px;cursor:pointer;margin-top:10px}
button:hover{background:#78b8ff}
.output{background:#0b0f19;padding:15px;border-radius:5px;word-break:break-all;font-size:13px;margin-top:10px}
footer{text-align:center;opacity:.6;margin-top:40px}
hr{border:1px solid #1f2a44;margin:30px 0}
</style>
</head>

<body>
<div class="container">

<h1>WHYTEGOD Protocol</h1>
<p>Cryptographically enforced peer coordination for ordinary people.</p>

<hr>

<div class="box">
<h2>Phase 11 — Hardened Protocol MVP</h2>
<p>
This system transforms human intent into immutable cryptographic truth,
verified by peers and anchored on Avalanche without tokens or smart contracts.
</p>
</div>

<div class="box">
<h3>1️⃣ Proposal Creation</h3>
<textarea id="userInput" placeholder="Enter a proposal, agreement, or financial rule..."></textarea>
<button onclick="runProtocol()">Generate Proposal</button>
<div id="proposalOutput" class="output">No proposal yet.</div>
</div>

<div class="box">
<h3>2️⃣ Cryptographic Hash</h3>
<div id="hashOutput" class="output">No hash yet.</div>
</div>

<div class="box">
<h3>3️⃣ Peer Verification (Minimum 3)</h3>
<input id="peerInput" placeholder="Paste the SAME proposal text to verify..." />
<button onclick="verifyPeer()">Submit Peer Verification</button>
<div id="peerOutput" class="output">0 / 3 peers verified.</div>
</div>

<div class="box">
<h3>4️⃣ Governance State</h3>
<div id="governanceOutput" class="output">Awaiting peer consensus.</div>
</div>

<div class="box">
<h3>5️⃣ Wallet Connection</h3>
<button onclick="connectWallet()">Connect MetaMask</button>
<div id="walletOutput" class="output">Not connected.</div>
</div>

<div class="box">
<h3>6️⃣ Avalanche Final Anchor</h3>
<button onclick="sendToAvalanche()">Finalize On Avalanche</button>
<div id="chainOutput" class="output">Not finalized.</div>
</div>

<div class="box">
<h3>Protocol Rules (Readable)</h3>
<p>
• Proposal ID = SHA256(text + timestamp + wallet)<br>
• Minimum peers required: 3<br>
• All peers must reproduce the same hash<br>
• Once finalized, proposal is locked forever<br>
• Avalanche is used only as a timestamp anchor
</p>
</div>

<footer>
<p>WHYTEGOD Protocol — Phase 11</p>
<p>Verification replaces trust.</p>
</footer>

</div>

<script>
let proposal=null;
let proposalHash="";
let peerCount=0;
let peerThreshold=3;
let userAccount=null;
let finalized=false;

async function runProtocol(){
if(finalized){alert("Proposal already finalized");return;}

const text=document.getElementById("userInput").value.trim();
if(!text){alert("Enter proposal text");return;}

const timestamp=new Date().toISOString();

proposal={
text:text,
timestamp:timestamp,
proposer:userAccount||"unconnected",
ai_role:"Assist only",
rule:"Deterministic peer verification"
};

document.getElementById("proposalOutput").textContent=
JSON.stringify(proposal,null,2);

const encoder=new TextEncoder();
const data=encoder.encode(JSON.stringify(proposal));
const hashBuffer=await crypto.subtle.digest("SHA-256",data);
const hashArray=Array.from(new Uint8Array(hashBuffer));
proposalHash=hashArray.map(b=>b.toString(16).padStart(2,"0")).join("");

peerCount=0;
document.getElementById("peerOutput").textContent="0 / "+peerThreshold+" peers verified.";
document.getElementById("hashOutput").textContent=proposalHash;
document.getElementById("governanceOutput").textContent="Proposal generated. Awaiting peers.";
}

async function verifyPeer(){
if(!proposal||finalized){return;}

const peerText=document.getElementById("peerInput").value.trim();
if(!peerText){alert("Paste proposal text");return;}

const encoder=new TextEncoder();
const data=encoder.encode(JSON.stringify({
text:peerText,
timestamp:proposal.timestamp,
proposer:proposal.proposer,
ai_role:"Assist only",
rule:"Deterministic peer verification"
}));

const hashBuffer=await crypto.subtle.digest("SHA-256",data);
const hashArray=Array.from(new Uint8Array(hashBuffer));
const peerHash=hashArray.map(b=>b.toString(16).padStart(2,"0")).join("");

if(peerHash===proposalHash){
peerCount++;
document.getElementById("peerOutput").textContent=
peerCount+" / "+peerThreshold+" peers verified.";

if(peerCount>=peerThreshold){
document.getElementById("governanceOutput").textContent=
"Consensus reached. Ready for finalization.";
}
}else{
document.getElementById("governanceOutput").textContent=
"Peer verification failed. Hash mismatch.";
}
}

async function connectWallet(){
if(!window.ethereum){alert("MetaMask not detected");return;}
const accounts=await ethereum.request({method:"eth_requestAccounts"});
userAccount=accounts[0];
document.getElementById("walletOutput").textContent="Connected: "+userAccount;
}

async function sendToAvalanche(){
if(finalized){alert("Already finalized");return;}
if(peerCount<peerThreshold){alert("Not enough peer verifications");return;}
if(!userAccount){alert("Connect wallet first");return;}

const tx={
from:userAccount,
to:userAccount,
value:"0x0",
data:"0x"+proposalHash
};

const txHash=await ethereum.request({
method:"eth_sendTransaction",
params:[tx]
});

finalized=true;
document.getElementById("chainOutput").textContent=
"FINALIZED — Avalanche TX: "+txHash;
document.getElementById("governanceOutput").textContent=
"Protocol locked. Immutable proof established.";
}
</script>

</body>
</html>