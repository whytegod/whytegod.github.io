<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Verify Commitment</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
</head>

<body>

<header>
  <h1>Verification</h1>
  <nav>
    <a href="index.html">Home</a>
    <a href="use.html">Use</a>
    <a href="use-cases.html">Use Cases</a>
    <a href="technology.html">Technology</a>
    <a href="verify.html">Verify</a>
    <a href="spec.html">Spec</a>
  </nav>
</header>

<main>
  <section>
    <h2>Verify Commitment</h2>
    <p>
      Recompute a SHA-256 hash and verify whether it matches an existing commitment.
    </p>

    <textarea
      id="verifyInput"
      placeholder="Paste the original data here"
      rows="6"></textarea>

    <input
      id="verifyHash"
      type="text"
      placeholder="Paste the commitment hash (hex)" />

    <button onclick="verify()">Verify Match</button>

    <div id="verifyResult"></div>

    <p class="note">
      Verification is deterministic: the same data always produces the same hash.
    </p>
  </section>
</main>

<footer>
  <p>Protocol verification tool — client-side, trustless, and deterministic.</p>
</footer>

<script>
async function verify() {
  const data = document.getElementById("verifyInput").value;
  const claimed = document.getElementById("verifyHash").value.trim().toLowerCase();
  const result = document.getElementById("verifyResult");

  if (!data || !claimed) {
    result.textContent = "⚠️ Both fields are required.";
    return;
  }

  const encoder = new TextEncoder();
  const buffer = await crypto.subtle.digest(
    "SHA-256",
    encoder.encode(data)
  );

  const hash = Array.from(new Uint8Array(buffer))
    .map(b => b.toString(16).padStart(2, "0"))
    .join("");

  if (hash === claimed) {
    result.textContent = "✅ Match — commitment is valid.";
  } else {
    result.textContent = "❌ No match — data was altered or hash is incorrect.";
  }
}
</script>

</body>
</html>